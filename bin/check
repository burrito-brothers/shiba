#!/usr/bin/env ruby

require 'bundler/setup'
require 'optionparser'
require 'shiba/checker'

MAGIC_COST = 100

options = {}
parser = OptionParser.new do |opts|
  opts.on("-f","--file FILE", "The explain output log to compare with") do |f|
    options["file"] = f
  end

  opts.on("--staged", "Only check files that are staged for commit") do
    options["staged"] = true
  end

  opts.on("--unstaged", "Only check files that are not staged for commit") do
    options["unstaged"] = true
  end

  opts.on("-b", "--branch GIT_BRANCH", "Compare to changes between HEAD and BRANCH") do |b|
    options["branch"] = b
  end

  opts.on("--verbose", "Verbose/debug mode") do
    options["verbose"] = true
  end
end
parser.parse!

# This is a noop since it's the default behavior. Ignore.
if options["staged"] && options["unstaged"]
  options.delete("staged")
  options.delete("unstaged")
end

explains = options["file"]

if explains.nil?
  $stderr.puts "Provide an explain log, or run 'shiba explain' to generate one."
  $stderr.puts parser.banner
  exit 1
end

if !File.exist?(explains)
  $stderr.puts "File not found: '#{explains}'"
  exit 1
end

result = Shiba::Checker.new(options).run(explains)

if result.message
  puts result.message
end

if result.problems
  $stderr.puts("")

  result.problems.each do |problem|
    sql = problem["sql"]
    sql.sub!(/select .*? where/i, '')
    line =  "#{File.basename(problem["backtrace"].first)}\t#{sql}"
    if line.length > 80
      line = line[0,80]
    end
    puts line
  end
end

code = case result.status
when :pass then 0
when :fail then 3
end

exit code